/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.courier.api.resources.send.types;

import com.courier.api.core.ObjectMappers;
import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonDeserialize(builder = BaseMessage.Builder.class)
public final class BaseMessage implements IBaseMessage {
    private final Optional<Map<String, Object>> data;

    private final Optional<String> brandId;

    private final Optional<Map<String, Channel>> channels;

    private final Optional<MessageContext> context;

    private final Optional<MessageMetadata> metadata;

    private final Optional<MessagePreferences> preferences;

    private final Optional<Map<String, MessageProvidersType>> providers;

    private final Optional<Routing> routing;

    private final Optional<Timeout> timeout;

    private final Optional<Delay> delay;

    private final Optional<Expiry> expiry;

    private final Map<String, Object> additionalProperties;

    private BaseMessage(
            Optional<Map<String, Object>> data,
            Optional<String> brandId,
            Optional<Map<String, Channel>> channels,
            Optional<MessageContext> context,
            Optional<MessageMetadata> metadata,
            Optional<MessagePreferences> preferences,
            Optional<Map<String, MessageProvidersType>> providers,
            Optional<Routing> routing,
            Optional<Timeout> timeout,
            Optional<Delay> delay,
            Optional<Expiry> expiry,
            Map<String, Object> additionalProperties) {
        this.data = data;
        this.brandId = brandId;
        this.channels = channels;
        this.context = context;
        this.metadata = metadata;
        this.preferences = preferences;
        this.providers = providers;
        this.routing = routing;
        this.timeout = timeout;
        this.delay = delay;
        this.expiry = expiry;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return An arbitrary object that includes any data you want to pass to the message.
     * The data will populate the corresponding template or elements variables.
     */
    @JsonProperty("data")
    @java.lang.Override
    public Optional<Map<String, Object>> getData() {
        return data;
    }

    @JsonProperty("brand_id")
    @java.lang.Override
    public Optional<String> getBrandId() {
        return brandId;
    }

    /**
     * @return &quot;Define run-time configuration for one or more channels. If you don't specify channels, the default configuration for each channel will be used. Valid ChannelId's are: email, sms, push, inbox, direct_message, banner, and webhook.&quot;
     */
    @JsonProperty("channels")
    @java.lang.Override
    public Optional<Map<String, Channel>> getChannels() {
        return channels;
    }

    /**
     * @return Context to load with this recipient. Will override any context set on message.context.
     */
    @JsonProperty("context")
    @java.lang.Override
    public Optional<MessageContext> getContext() {
        return context;
    }

    /**
     * @return Metadata such as utm tracking attached with the notification through this channel.
     */
    @JsonProperty("metadata")
    @java.lang.Override
    public Optional<MessageMetadata> getMetadata() {
        return metadata;
    }

    @JsonProperty("preferences")
    @java.lang.Override
    public Optional<MessagePreferences> getPreferences() {
        return preferences;
    }

    /**
     * @return An object whose keys are valid provider identifiers which map to an object.
     */
    @JsonProperty("providers")
    @java.lang.Override
    public Optional<Map<String, MessageProvidersType>> getProviders() {
        return providers;
    }

    @JsonProperty("routing")
    @java.lang.Override
    public Optional<Routing> getRouting() {
        return routing;
    }

    /**
     * @return Time in ms to attempt the channel before failing over to the next available channel.
     */
    @JsonProperty("timeout")
    @java.lang.Override
    public Optional<Timeout> getTimeout() {
        return timeout;
    }

    /**
     * @return Defines the time to wait before delivering the message. You can specify one of the following options. Duration with the number of milliseconds to delay. Until with an ISO 8601 timestamp that specifies when it should be delivered. Until with an OpenStreetMap opening_hours-like format that specifies the <a href="https://www.courier.com/docs/platform/sending/failover/#delivery-window">Delivery Window</a> (e.g., 'Mo-Fr 08:00-18:00pm')
     */
    @JsonProperty("delay")
    @java.lang.Override
    public Optional<Delay> getDelay() {
        return delay;
    }

    /**
     * @return &quot;Expiry allows you to set an absolute or relative time in which a message expires.
     * Note: This is only valid for the Courier Inbox channel as of 12-08-2022.&quot;
     */
    @JsonProperty("expiry")
    @java.lang.Override
    public Optional<Expiry> getExpiry() {
        return expiry;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof BaseMessage && equalTo((BaseMessage) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(BaseMessage other) {
        return data.equals(other.data)
                && brandId.equals(other.brandId)
                && channels.equals(other.channels)
                && context.equals(other.context)
                && metadata.equals(other.metadata)
                && preferences.equals(other.preferences)
                && providers.equals(other.providers)
                && routing.equals(other.routing)
                && timeout.equals(other.timeout)
                && delay.equals(other.delay)
                && expiry.equals(other.expiry);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(
                this.data,
                this.brandId,
                this.channels,
                this.context,
                this.metadata,
                this.preferences,
                this.providers,
                this.routing,
                this.timeout,
                this.delay,
                this.expiry);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<Map<String, Object>> data = Optional.empty();

        private Optional<String> brandId = Optional.empty();

        private Optional<Map<String, Channel>> channels = Optional.empty();

        private Optional<MessageContext> context = Optional.empty();

        private Optional<MessageMetadata> metadata = Optional.empty();

        private Optional<MessagePreferences> preferences = Optional.empty();

        private Optional<Map<String, MessageProvidersType>> providers = Optional.empty();

        private Optional<Routing> routing = Optional.empty();

        private Optional<Timeout> timeout = Optional.empty();

        private Optional<Delay> delay = Optional.empty();

        private Optional<Expiry> expiry = Optional.empty();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(BaseMessage other) {
            data(other.getData());
            brandId(other.getBrandId());
            channels(other.getChannels());
            context(other.getContext());
            metadata(other.getMetadata());
            preferences(other.getPreferences());
            providers(other.getProviders());
            routing(other.getRouting());
            timeout(other.getTimeout());
            delay(other.getDelay());
            expiry(other.getExpiry());
            return this;
        }

        @JsonSetter(value = "data", nulls = Nulls.SKIP)
        public Builder data(Optional<Map<String, Object>> data) {
            this.data = data;
            return this;
        }

        public Builder data(Map<String, Object> data) {
            this.data = Optional.of(data);
            return this;
        }

        @JsonSetter(value = "brand_id", nulls = Nulls.SKIP)
        public Builder brandId(Optional<String> brandId) {
            this.brandId = brandId;
            return this;
        }

        public Builder brandId(String brandId) {
            this.brandId = Optional.of(brandId);
            return this;
        }

        @JsonSetter(value = "channels", nulls = Nulls.SKIP)
        public Builder channels(Optional<Map<String, Channel>> channels) {
            this.channels = channels;
            return this;
        }

        public Builder channels(Map<String, Channel> channels) {
            this.channels = Optional.of(channels);
            return this;
        }

        @JsonSetter(value = "context", nulls = Nulls.SKIP)
        public Builder context(Optional<MessageContext> context) {
            this.context = context;
            return this;
        }

        public Builder context(MessageContext context) {
            this.context = Optional.of(context);
            return this;
        }

        @JsonSetter(value = "metadata", nulls = Nulls.SKIP)
        public Builder metadata(Optional<MessageMetadata> metadata) {
            this.metadata = metadata;
            return this;
        }

        public Builder metadata(MessageMetadata metadata) {
            this.metadata = Optional.of(metadata);
            return this;
        }

        @JsonSetter(value = "preferences", nulls = Nulls.SKIP)
        public Builder preferences(Optional<MessagePreferences> preferences) {
            this.preferences = preferences;
            return this;
        }

        public Builder preferences(MessagePreferences preferences) {
            this.preferences = Optional.of(preferences);
            return this;
        }

        @JsonSetter(value = "providers", nulls = Nulls.SKIP)
        public Builder providers(Optional<Map<String, MessageProvidersType>> providers) {
            this.providers = providers;
            return this;
        }

        public Builder providers(Map<String, MessageProvidersType> providers) {
            this.providers = Optional.of(providers);
            return this;
        }

        @JsonSetter(value = "routing", nulls = Nulls.SKIP)
        public Builder routing(Optional<Routing> routing) {
            this.routing = routing;
            return this;
        }

        public Builder routing(Routing routing) {
            this.routing = Optional.of(routing);
            return this;
        }

        @JsonSetter(value = "timeout", nulls = Nulls.SKIP)
        public Builder timeout(Optional<Timeout> timeout) {
            this.timeout = timeout;
            return this;
        }

        public Builder timeout(Timeout timeout) {
            this.timeout = Optional.of(timeout);
            return this;
        }

        @JsonSetter(value = "delay", nulls = Nulls.SKIP)
        public Builder delay(Optional<Delay> delay) {
            this.delay = delay;
            return this;
        }

        public Builder delay(Delay delay) {
            this.delay = Optional.of(delay);
            return this;
        }

        @JsonSetter(value = "expiry", nulls = Nulls.SKIP)
        public Builder expiry(Optional<Expiry> expiry) {
            this.expiry = expiry;
            return this;
        }

        public Builder expiry(Expiry expiry) {
            this.expiry = Optional.of(expiry);
            return this;
        }

        public BaseMessage build() {
            return new BaseMessage(
                    data,
                    brandId,
                    channels,
                    context,
                    metadata,
                    preferences,
                    providers,
                    routing,
                    timeout,
                    delay,
                    expiry,
                    additionalProperties);
        }
    }
}
